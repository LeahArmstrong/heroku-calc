package report

import (
	"fmt"
	"strings"
	"time"

	"github.com/egg/heroku-calc/internal/config"
)

// GenerateMarkdown creates a markdown report from analysis results
func GenerateMarkdown(appName string, result *config.AnalysisResult) string {
	var sb strings.Builder

	// Header
	sb.WriteString(fmt.Sprintf("# Heroku Configuration Analysis Report\n\n"))
	sb.WriteString(fmt.Sprintf("**Application:** %s  \n", appName))
	sb.WriteString(fmt.Sprintf("**Generated:** %s  \n\n", time.Now().Format("2006-01-02 15:04:05 MST")))

	sb.WriteString("---\n\n")

	// Executive Summary
	sb.WriteString("## Executive Summary\n\n")
	sb.WriteString(generateExecutiveSummary(result))
	sb.WriteString("\n\n")

	// Database Analysis
	if result.DatabaseAnalysis != nil {
		sb.WriteString("## Database Configuration\n\n")
		sb.WriteString(generateDatabaseSection(result.DatabaseAnalysis))
		sb.WriteString("\n\n")
	}

	// Redis Analysis
	if result.RedisAnalysis != nil {
		sb.WriteString("## Redis Configuration\n\n")
		sb.WriteString(generateRedisSection(result.RedisAnalysis))
		sb.WriteString("\n\n")
	}

	// Web Tier Analysis
	if result.WebTierAnalysis != nil {
		sb.WriteString("## Web Tier Configuration\n\n")
		sb.WriteString(generateWebTierSection(result.WebTierAnalysis))
		sb.WriteString("\n\n")
	}

	// Recommendations
	if len(result.Recommendations) > 0 {
		sb.WriteString("## Recommendations\n\n")
		sb.WriteString(generateRecommendationsSection(result.Recommendations))
		sb.WriteString("\n\n")
	}

	// Footer
	sb.WriteString("---\n\n")
	sb.WriteString("*Report generated by [Heroku Config Analyzer](https://github.com/egg/heroku-calc)*\n")

	return sb.String()
}

func generateExecutiveSummary(result *config.AnalysisResult) string {
	var sb strings.Builder

	criticalCount := 0
	warningCount := 0

	for _, rec := range result.Recommendations {
		switch rec.Severity {
		case config.SeverityCritical:
			criticalCount++
		case config.SeverityHigh, config.SeverityMedium:
			warningCount++
		}
	}

	if criticalCount > 0 {
		sb.WriteString(fmt.Sprintf("üî¥ **Critical Issues Found:** %d issue(s) require immediate attention  \n", criticalCount))
	}
	if warningCount > 0 {
		sb.WriteString(fmt.Sprintf("üü° **Warnings:** %d recommendation(s) for optimization  \n", warningCount))
	}
	if criticalCount == 0 && warningCount == 0 {
		sb.WriteString("üü¢ **Status:** Configuration appears optimal  \n")
	}

	return sb.String()
}

func generateDatabaseSection(analysis *config.DatabaseAnalysis) string {
	var sb strings.Builder

	// Status
	sb.WriteString(fmt.Sprintf("**Status:** %s  \n", formatStatus(analysis.Status)))
	sb.WriteString(fmt.Sprintf("**Plan:** %s  \n\n", analysis.PostgresPlan))

	// Connection Analysis Table
	sb.WriteString("### Connection Analysis\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Max Connections | %d |\n", analysis.MaxConnections))
	sb.WriteString(fmt.Sprintf("| Web Dynos | %d |\n", analysis.WebDynos))
	sb.WriteString(fmt.Sprintf("| Workers per Dyno | %d |\n", analysis.WorkersPerDyno))
	sb.WriteString(fmt.Sprintf("| Threads per Worker | %d |\n", analysis.ThreadsPerWorker))
	sb.WriteString(fmt.Sprintf("| Web Connections | %d |\n", analysis.WebDynos*analysis.WorkersPerDyno*analysis.ThreadsPerWorker))
	if analysis.SidekiqDynos > 0 {
		sb.WriteString(fmt.Sprintf("| Sidekiq Dynos | %d |\n", analysis.SidekiqDynos))
		sb.WriteString(fmt.Sprintf("| Sidekiq Threads | %d |\n", analysis.SidekiqThreads))
		sb.WriteString(fmt.Sprintf("| Worker Connections | %d |\n", analysis.SidekiqDynos*analysis.SidekiqThreads))
	}
	sb.WriteString(fmt.Sprintf("| **Total Required** | **%d** |\n", analysis.TotalRequired))
	sb.WriteString(fmt.Sprintf("| **Available Buffer** | **%.1f%%** |\n\n", analysis.BufferPercent))

	// Issues
	if len(analysis.Issues) > 0 {
		sb.WriteString("### Issues\n\n")
		for _, issue := range analysis.Issues {
			sb.WriteString(fmt.Sprintf("- %s\n", issue))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func generateRedisSection(analysis *config.RedisAnalysis) string {
	var sb strings.Builder

	// Status
	sb.WriteString(fmt.Sprintf("**Status:** %s  \n", formatStatus(analysis.Status)))
	sb.WriteString(fmt.Sprintf("**Plan:** %s  \n\n", analysis.RedisPlan))

	if analysis.RedisURL == "unknown" {
		sb.WriteString("*Redis not configured for this application*\n")
		return sb.String()
	}

	// Connection Analysis Table
	sb.WriteString("### Connection Analysis\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Max Connections | %d |\n", analysis.MaxConnections))
	sb.WriteString(fmt.Sprintf("| Sidekiq Concurrency | %d |\n", analysis.SidekiqConcurrency))
	sb.WriteString(fmt.Sprintf("| Redis Pool Size | %d |\n", analysis.RedisPoolSize))
	sb.WriteString(fmt.Sprintf("| **Estimated Usage** | **%d** |\n", analysis.EstimatedUsage))
	if analysis.MaxConnections > 0 {
		utilizationPercent := float64(analysis.EstimatedUsage) / float64(analysis.MaxConnections) * 100
		sb.WriteString(fmt.Sprintf("| **Utilization** | **%.1f%%** |\n\n", utilizationPercent))
	}

	// Issues
	if len(analysis.Issues) > 0 {
		sb.WriteString("### Issues\n\n")
		for _, issue := range analysis.Issues {
			sb.WriteString(fmt.Sprintf("- %s\n", issue))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func generateWebTierSection(analysis *config.WebTierAnalysis) string {
	var sb strings.Builder

	// Status
	sb.WriteString(fmt.Sprintf("**Status:** %s  \n", formatStatus(analysis.Status)))
	sb.WriteString(fmt.Sprintf("**Dyno Type:** %s  \n\n", analysis.DynoType))

	// Configuration Table
	sb.WriteString("### Configuration\n\n")
	sb.WriteString("| Metric | Value |\n")
	sb.WriteString("|--------|-------|\n")
	sb.WriteString(fmt.Sprintf("| Dyno Memory | %d MB |\n", analysis.DynoMemoryMB))
	sb.WriteString(fmt.Sprintf("| WEB_CONCURRENCY | %d |\n", analysis.WebConcurrency))
	sb.WriteString(fmt.Sprintf("| RAILS_MAX_THREADS | %d |\n", analysis.RailsMaxThreads))
	sb.WriteString(fmt.Sprintf("| **Total Threads** | **%d** |\n", analysis.TotalThreads))
	if analysis.MemoryPerThread > 0 {
		sb.WriteString(fmt.Sprintf("| **Memory per Thread** | **%d MB** |\n\n", analysis.MemoryPerThread))
	}

	// Issues
	if len(analysis.Issues) > 0 {
		sb.WriteString("### Issues\n\n")
		for _, issue := range analysis.Issues {
			sb.WriteString(fmt.Sprintf("- %s\n", issue))
		}
		sb.WriteString("\n")
	}

	return sb.String()
}

func generateRecommendationsSection(recommendations []config.Recommendation) string {
	var sb strings.Builder

	// Group recommendations by severity
	critical := []config.Recommendation{}
	high := []config.Recommendation{}
	medium := []config.Recommendation{}
	low := []config.Recommendation{}

	for _, rec := range recommendations {
		switch rec.Severity {
		case config.SeverityCritical:
			critical = append(critical, rec)
		case config.SeverityHigh:
			high = append(high, rec)
		case config.SeverityMedium:
			medium = append(medium, rec)
		default:
			low = append(low, rec)
		}
	}

	// Critical recommendations
	if len(critical) > 0 {
		sb.WriteString("### üî¥ Critical Priority\n\n")
		for _, rec := range critical {
			sb.WriteString(formatRecommendation(rec))
		}
	}

	// High priority recommendations
	if len(high) > 0 {
		sb.WriteString("### üü† High Priority\n\n")
		for _, rec := range high {
			sb.WriteString(formatRecommendation(rec))
		}
	}

	// Medium priority recommendations
	if len(medium) > 0 {
		sb.WriteString("### üü° Medium Priority\n\n")
		for _, rec := range medium {
			sb.WriteString(formatRecommendation(rec))
		}
	}

	// Low priority recommendations
	if len(low) > 0 {
		sb.WriteString("### üü¢ Low Priority\n\n")
		for _, rec := range low {
			sb.WriteString(formatRecommendation(rec))
		}
	}

	return sb.String()
}

func formatRecommendation(rec config.Recommendation) string {
	var sb strings.Builder

	sb.WriteString(fmt.Sprintf("#### %s\n\n", rec.Title))
	sb.WriteString(fmt.Sprintf("**Category:** %s  \n", rec.Category))
	sb.WriteString(fmt.Sprintf("**Description:** %s  \n\n", rec.Description))

	sb.WriteString("| | |\n")
	sb.WriteString("|---|---|\n")
	sb.WriteString(fmt.Sprintf("| **Current** | %s |\n", rec.Current))
	sb.WriteString(fmt.Sprintf("| **Suggested** | %s |\n", rec.Suggested))
	if rec.Impact != "" {
		sb.WriteString(fmt.Sprintf("| **Impact** | %s |\n", rec.Impact))
	}
	if rec.EnvVarName != "" {
		sb.WriteString(fmt.Sprintf("| **Env Var** | `%s` |\n", rec.EnvVarName))
	}
	if rec.AutoApply {
		sb.WriteString("| **Auto-Apply** | ‚úÖ Yes |\n")
	} else {
		sb.WriteString("| **Auto-Apply** | ‚ùå Manual Required |\n")
	}
	sb.WriteString("\n")

	return sb.String()
}

func formatStatus(status config.AnalysisStatus) string {
	switch status {
	case config.StatusCritical:
		return "üî¥ Critical"
	case config.StatusWarning:
		return "üü° Warning"
	case config.StatusOptimal:
		return "üü¢ Optimal"
	default:
		return "‚ö™ Unknown"
	}
}

// SaveToFile saves the markdown report to a file
func SaveToFile(content, filename string) error {
	return nil // Implemented in formatter.go
}
